#!/usr/bin/env python
""" Module to initialize and run Checkmate server"""
import json
import os
import logging
import string
import sys

# Init logging before we load the database, 3rd party, and 'noisy' modules
from checkmate.utils import init_console_logging
init_console_logging()
# pylint: disable=E0611
from bottle import app, run, request, response, error, HeaderDict, \
        default_app, load

LOG = logging.getLogger(__name__)

from checkmate.exceptions import CheckmateException, CheckmateNoMapping
<<<<<<< HEAD
from checkmate import middleware
from checkmate.utils import STATIC
=======
from checkmate.utils import HANDLERS, RESOURCES, STATIC, write_body, \
        read_body, support_only

db = get_driver()


def init():
    # Load routes (must run before loading routes below)
    from checkmate import simulator
    from checkmate import blueprints, components, deployments, environments, \
            workflows

    # Register built-in providers
    from checkmate.providers import rackspace, opscode

init()


#
# Making life easy - calls that are handy but will not be in final API
#
@post('/test/parse')
def parse():
    """ For debugging only """
    return write_body(read_body(request), request, response)


@post('/test/hack')
def hack():
    """ Use it to test random stuff """
    entity = read_body(request)
    if 'deployment' in entity:
        entity = entity['deployment']

    if 'id' not in entity:
        entity['id'] = uuid.uuid4().hex
    if any_id_problems(entity['id']):
        abort(406, any_id_problems(entity['id']))

    from checkmate.deployments import Deployment, plan
    dep = Deployment(entity)
    plan(dep, request.context)

    from checkmate.workflows import create_workflow
    wf = create_workflow(dep, request.context)

    from SpiffWorkflow.storage import DictionarySerializer
    serializer = DictionarySerializer()
    data = serializer._serialize_task_spec(
             wf.spec.task_specs['Collect apache2 Chef Data: 4'])

    return write_body(data, request, response)


@get('/test/async')
def async():
    """Test async responses"""
    response.set_header('content-type', "application/json")
    response.set_header('Location', "uri://something")

    def afunc():
        yield ('{"Note": "To watch this in real-time, run: curl '\
                'http://localhost:8080/test/async -N -v",')
        sleep(1)
        for i in range(3):
            yield '"%i": "Counting",' % i
            sleep(1)
        yield '"Done": 3}'
    return afunc()


#
# Status and System Information
#
@get('/status/celery')
def get_celery_worker_status():
    """ Checking on celery """
    ERROR_KEY = "ERROR"
    try:
        from celery.task.control import inspect
        insp = inspect()
        d = insp.stats()
        if not d:
            d = {ERROR_KEY: 'No running Celery workers were found.'}
    except IOError as e:
        from errno import errorcode
        msg = "Error connecting to the backend: " + str(e)
        if len(e.args) > 0 and errorcode.get(e.args[0]) == 'ECONNREFUSED':
            msg += ' Check that the RabbitMQ server is running.'
        d = {ERROR_KEY: msg}
    except ImportError as e:
        d = {ERROR_KEY: str(e)}
    return write_body(d, request, response)


@get('/status/libraries')
def get_dependency_versions():
    """ Checking on dependencies """
    result = {}
    libraries = [
                'bottle',  # HTTP request router
                'celery',  # asynchronous/queued call wrapper
                'Jinja2',  # templating library for HTML calls
                'kombu',   # message queue interface (dependency for celery)
                'openstack.compute',  # Rackspace CLoud Server (legacy) library
                'paramiko',  # SSH library
                'pycrypto',  # Cryptography (key generation)
                'python-novaclient',  # OpenStack Compute client library
                'python-clouddb',  # Rackspace DBaaS client library
                'pyyaml',  # YAML parser
                'SpiffWorkflow',  # Workflow Engine
                'sqlalchemy',  # ORM
                'sqlalchemy-migrate',  # database schema versioning
                'webob',   # HTTP request handling
                ]  # copied from setup.py with additions added
    for library in libraries:
        result[library] = {}
        try:
            if library in sys.modules:
                module = sys.modules[library]
                if hasattr(module, '__version__'):
                    result[library]['version'] = module.__version__
                result[library]['path'] = getattr(module, '__path__', 'N/A')
                result[library]['status'] = 'loaded'
            else:
                result[library]['status'] = 'not loaded'
        except Exception as exc:
            result[library]['status'] = 'ERROR: %s' % exc

    # Chef version
    try:
        output = check_output(['knife', '-v'])
        result['knife'] = {'version': output.strip()}
    except Exception as exc:
        result['knife'] = {'status': 'ERROR: %s' % exc}

    # Chef version
    expected = ['knife-solo',  'knife-solo_data_bag']
    try:
        output = check_output(['gem', 'list', 'knife-solo'])

        if output:
            for line in output.split('\n'):
                for name in expected[:]:
                    if line.startswith('%s ' % name):
                        output = line
                        result[name] = {'version': output.strip()}
                        expected.remove(name)
        for name in expected:
            result[name] = {'status': 'missing'}
    except Exception as exc:
        for name in expected:
            result[name] = {'status': 'ERROR: %s' % exc}

    return write_body(result, request, response)


class TenantMiddleware(object):
    """Strips /tenant_id/ from path and puts it in context

    This is needed by the authz middleware too
    """
    def __init__(self, app):
        self.app = app

    def __call__(self, e, h):
        # Clear headers if supplied (anti-spoofing)
        self._remove_auth_headers(e)

        if e['PATH_INFO'] in [None, "", "/"]:
            pass  # Not a tenant call
        else:
            path_parts = e['PATH_INFO'].split('/')
            tenant = path_parts[1]
            if tenant in RESOURCES or tenant in STATIC:
                pass  # Not a tenant call
            else:
                errors = any_tenant_id_problems(tenant)
                if errors:
                    return HTTPNotFound(errors)(e, h)
                context = request.context
                rewrite = "/%s" % '/'.join(path_parts[2:])
                LOG.debug("Rewrite for tenant %s from '%s' "
                        "to '%s'" % (tenant, e['PATH_INFO'], rewrite))
                context.tenant = tenant
                e['PATH_INFO'] = rewrite

        return self.app(e, h)

    def _remove_auth_headers(self, env):
        """Remove headers so a user can't fake authentication.

        :param env: wsgi request environment

        """
        auth_headers = (
            'X-Identity-Status',
            'X-Tenant-Id',
            'X-Tenant-Name',
            'X-User-Id',
            'X-User-Name',
            'X-Roles',
            # Deprecated
            'X-User',
            'X-Tenant',
            'X-Role',
        )
        self._remove_headers(env, auth_headers)

    def _remove_headers(self, env, keys):
        """Remove http headers from environment."""
        for k in keys:
            env_key = self._header_to_env_var(k)
            if env_key in env:
                LOG.debug('Removing header from request environment: %s' %
                        env_key)
                del env[env_key]

    def _header_to_env_var(self, key):
        """Convert header to wsgi env variable.

        :param key: http header name (ex. 'X-Auth-Token')
        :return wsgi env variable name (ex. 'HTTP_X_AUTH_TOKEN')

        """
        return  'HTTP_%s' % key.replace('-', '_').upper()

    def _add_headers(self, env, headers):
        """Add http headers to environment."""
        for (k, v) in headers.iteritems():
            env_key = self._header_to_env_var(k)
            env[env_key] = v


class PAMAuthMiddleware(object):
    """Authenticate basic auth calls to PAM and optionally mark user as admin

    - Authenticates any basic auth to PAM
        - 401 if fails
        - Mark authenticated as admin if all_admins is set
        - checks for domain if set. Ignores other domains otherwise
    - Adds basic auth header to any returning calls so client knows basic
      auth is supported
    """
    def __init__(self, app, domain=None, all_admins=False):
        self.app = app
        self.domain = None  # Which domain to authenticate in this instance
        self.all_admins = all_admins  # Does this authenticate admins?

    def __call__(self, e, h):
        # Authenticate basic auth calls to PAM
        #TODO: this header is not being returned in a 401
        h = self.start_response_callback(h)
        context = request.context

        if 'HTTP_AUTHORIZATION' in e:
            if getattr(context, 'authenticated', False) == True:
                return self.app(e, h)

            auth = e['HTTP_AUTHORIZATION'].split()
            if len(auth) == 2:
                if auth[0].lower() == "basic":
                    login, passwd = base64.b64decode(auth[1]).split(':')
                    username = login
                    if self.domain:
                        if '\\' in login:
                            domain = login.split('\\')[0]
                            if domain != self.domain:
                                # Does not apply to this instance. Pass through
                                return self.app(e, h)
                            username = login.split('\\')[len(domain) + 1:]
                    # TODO: maybe implement some caching?
                    if not pam.authenticate(login, passwd, service='login'):
                        LOG.debug('PAM failing request because of bad creds')
                        return HTTPUnauthorized("Invalid credentials")(e, h)
                    LOG.debug("PAM authenticated '%s' as admin" % login)
                    context.domain = self.domain
                    context.username = username
                    context.authenticated = True
                    context.is_admin = self.all_admins

        return self.app(e, h)

    def start_response_callback(self, start_response):
        """Intercepts upstream start_response and adds our headers"""
        def callback(status, headers, exc_info=None):
            # Add our headers to response
            headers.append(('WWW-Authenticate',
                    'Basic realm="Checkmate PAM Module"'))
            # Call upstream start_response
            start_response(status, headers, exc_info)
        return callback


class TokenAuthMiddleware(object):
    """Authenticate any tokens provided.

    - Appends www-authenticate headers to returning calls
    - Authenticates all tokens passed in with X-Auth-Token
        - 401s if invalid
        - Marks authenticated if valid and populates user and catalog data
    """
    def __init__(self, app, endpoint):
        self.app = app
        self.endpoint = endpoint

    def __call__(self, e, h):
        # Authenticate calls with X-Auth-Token to the source auth service
        h = self.start_response_callback(h)

        if 'HTTP_X_AUTH_TOKEN' in e:
            context = request.context
            try:
                content = self._auth_keystone(context,
                        token=e['HTTP_X_AUTH_TOKEN'])
            except HTTPUnauthorized as exc:
                LOG.exception(exc)
                return exc(e, h)
            context.set_context(content)
        return self.app(e, h)

    def _auth_keystone(self, context, token=None, username=None,
                apikey=None, password=None):
        url = urlparse(self.endpoint)
        if url.scheme == 'https':
            http_class = httplib.HTTPSConnection
            port = url.port or 443
        else:
            http_class = httplib.HTTPConnection
            port = url.port or 80
        host = url.hostname

        http = http_class(host, port)
        if token:
            body = {"auth": {"token": {"id": token}}}
        elif password:
            body = {"auth": {"passwordCredentials": {
                    "username": username, 'password': password}}}
        elif apikey:
            body = {"auth": {"RAX-KSKEY:apiKeyCredentials": {
                    "username": username, 'apiKey': apikey}}}

        if context.tenant:
            auth = body['auth']
            auth['tenantId'] = context.tenant
            LOG.debug("Authenticating to tenant '%s'" % context.tenant)
        headers = {
                'Content-type': 'application/json',
                'Accept': 'application/json',
            }
        # TODO: implement some caching to not overload auth
        try:
            LOG.debug('Authenticating to %s' % self.endpoint)
            http.request('POST', url.path, body=json.dumps(body),
                    headers=headers)
            resp = http.getresponse()
            body = resp.read()
        except Exception, e:
            LOG.error('HTTP connection exception: %s' % e)
            raise HTTPUnauthorized('Unable to communicate with keystone')
        finally:
            http.close()

        if resp.status != 200:
            LOG.debug('Invalid token for tenant: %s' % resp.reason)
            raise HTTPUnauthorized("Token invalid or not valid for "
                    "this tenant (%s)" % resp.reason)

        try:
            content = json.loads(body)
        except ValueError:
            msg = 'Keystone did not return json-encoded body'
            LOG.debug(msg)
            raise HTTPUnauthorized(msg)
        return content

    def start_response_callback(self, start_response):
        """Intercepts upstream start_response and adds our headers"""
        def callback(status, headers, exc_info=None):
            # Add our headers to response
            headers.append(('WWW-Authenticate',
                            'Keystone uri="%s"' % self.endpoint))
            # Call upstream start_response
            start_response(status, headers, exc_info)
        return callback


class AuthorizationMiddleware(object):
    """Checks that call is authenticated and authorized to access the resource
    requested.

    - Allows all calls to anonymous_paths
    - Allows all calls that have been validated
    - Denies all others (redirect to tenant URL if we have the tenant)
    Note: calls authenticated with PAM will not have an auth_token. They will
          not be able to access calls that need an auth token
    """
    def __init__(self, app, anonymous_paths=None):
        self.app = app
        self.anonymous_paths = anonymous_paths

    def __call__(self, e, h):
        path_parts = e['PATH_INFO'].split('/')
        root = path_parts[1] if len(path_parts) > 1 else None
        if root in self.anonymous_paths:
            # Allow test and static calls
            return self.app(e, h)

        context = request.context

        if context.is_admin == True:
            # Allow all admin calls
            return self.app(e, h)
        elif context.tenant:
            # Authorize tenant calls
            if not context.authenticated:
                LOG.debug('Authentication required for this resource')
                return HTTPUnauthorized()(e, h)
            if not context.allowed_to_access_tenant():
                LOG.debug('Access to tenant not allowed')
                return HTTPUnauthorized("Access to tenant not allowed")(e, h)
            return self.app(e, h)
        elif root in RESOURCES or root is None:
            # Failed attempt to access admin resource
            if context.user_tenants:
                for tenant in context.user_tenants:
                    if 'Mosso' not in tenant:
                        LOG.debug('Redirecting to tenant')
                        return HTTPFound(location='/%s%s' % (tenant,
                                e['PATH_INFO']))(e, h)

        LOG.debug('Auth-Z failed. Returning 401.')
        return HTTPUnauthorized()(e, h)


class StripPathMiddleware(object):
    """Strips extra / at end of path"""
    def __init__(self, app):
        self.app = app

    def __call__(self, e, h):
        e['PATH_INFO'] = e['PATH_INFO'].rstrip('/')
        return self.app(e, h)


class ExtensionsMiddleware(object):
    """Converts extensions to accept headers: yaml, json, html"""
    def __init__(self, app):
        self.app = app

    def __call__(self, e, h):
        if e['PATH_INFO'] in [None, "", "/"]:
            return self.app(e, h)
        else:
            path_parts = e['PATH_INFO'].split('/')
            root = path_parts[1]
            if root in RESOURCES or root in STATIC:
                return self.app(e, h)

        if e['PATH_INFO'].endswith('.json'):
            webob.Request(e).accept = 'application/json'
            e['PATH_INFO'] = e['PATH_INFO'][0:-5]
        elif e['PATH_INFO'].endswith('.yaml'):
            webob.Request(e).accept = 'application/x-yaml'
            e['PATH_INFO'] = e['PATH_INFO'][0:-5]
        elif e['PATH_INFO'].endswith('.html'):
            webob.Request(e).accept = 'text/html'
            e['PATH_INFO'] = e['PATH_INFO'][0:-5]
        return self.app(e, h)


class BrowserMiddleware(object):
    """Adds support for browser interaction and HTML content

    Adds these paths:
        /favicon.ico - returns Checkmate icon
        /authproxy for Ajax clients to authenticate (to address CORS)
        /static to serve static files
        /images to serve static files for add-ons like RackspaceCalculator

    Handles text/html requests as follows:
        - authenticated: render using bottle routes and text/html HANDLER
        - unauthenticated to anonymous route: use normal bottle route
        - unauthenticated to resource route: render root UI so client can auth
    """

    def __init__(self, app, proxy_endpoints=None):
        self.app = app
        HANDLERS['text/html'] = BrowserMiddleware.write_html
        STATIC.extend(['static', 'favicon.ico', 'apple-touch-icon.png',
                'authproxy', 'marketing', 'admin', '', 'images', 'ui', None])
        self.proxy_endpoints = proxy_endpoints

        # Add static routes
        @get('/favicon.ico')
        def favicon():
            """Without this, browsers keep getting a 404 and users perceive
            slow response """
            return static_file('favicon.ico',
                    root=os.path.join(os.path.dirname(__file__), 'static'))
>>>>>>> 3afaa0563c7f616f09e823a53c46c0cc64ea9105


@error(code=500)
def custom_500(error):
    """Catch 500 errors that originate from a CheckmateExcption and output the
    Checkmate error information (more useful than a blind 500)"""
    accept = request.get_header("Accept")
    if "application/json" in accept:
        error.headers = HeaderDict({"content-type": "application/json"})
        error.apply(response)
    elif "application/x-yaml" in accept:
        error.headers = HeaderDict({"content-type": "application/x-yaml"})
        error.apply(response)
        #error.set_header = lambda s, h, v: LOG.debug(s)
    if isinstance(error.exception, CheckmateNoMapping):
        error.status = '406 Bad Request'
        error.output = error.exception.__str__()
    elif isinstance(error.exception, CheckmateException):
        error.status = '406 Bad Request'
        error.output = json.dumps(error.exception.__str__())

    return error.output #write_body(error, request, response)


#if __name__ == '__main__':
def main_func():
    # Load routes from other modules
    LOG.info("Loading API")
    load("checkmate.api")
    if '--with-simulator' in sys.argv:
        load("checkmate.simulator")

    # Register built-in providers
    from checkmate.providers import rackspace, opscode

    # Build WSGI Chain:
    LOG.info("Loading Application")
    next_app = default_app()  # This is the main checkmate app
    app.error_handler = {500: custom_500}
    next_app.catch_all = True  # Handle errors ourselves so we can format them
    next_app = middleware.ExceptionMiddleware(next_app)
    next_app = middleware.AuthorizationMiddleware(next_app, anonymous_paths=STATIC)
    #next = middleware.PAMAuthMiddleware(next, all_admins=True)
    endpoints = ['https://identity.api.rackspacecloud.com/v2.0/tokens',
            'https://lon.identity.api.rackspacecloud.com/v2.0/tokens']
    next_app = middleware.AuthTokenRouterMiddleware(next_app, endpoints,
            default='https://identity.api.rackspacecloud.com/v2.0/tokens')
    """
    if '--with-ui' in sys.argv:
        # With a UI, we use basic auth and route that to cloud auth.
        domains = {
                'UK': {
                        'protocol': 'keystone',
                        'endpoint':
                                'https://lon.identity.api.rackspacecloud.com/'
                                'v2.0/tokens',
                    },
                'US': {
                        'protocol': 'keystone',
                        'endpoint': 'https://identity.api.rackspacecloud.com/'
                        'v2.0/tokens',
                    },
            }
        next = middleware.BasicAuthMultiCloudMiddleware(next, domains=domains)
    """
    if '--with-ui' in sys.argv:
        next_app = middleware.BrowserMiddleware(next_app, proxy_endpoints=endpoints)
    next_app = middleware.TenantMiddleware(next_app)
    next_app = middleware.ContextMiddleware(next_app)
    next_app = middleware.StripPathMiddleware(next_app)
    next_app = middleware.ExtensionsMiddleware(next_app)
    next_app = middleware.CatchAll404(next_app)
    if '--newrelic' in sys.argv:
        import newrelic.agent
        newrelic.agent.initialize(os.path.normpath(os.path.join(
                os.path.dirname(__file__), os.path.pardir,
                'newrelic.ini')))  # optional param ->, 'staging')
        next_app = newrelic.agent.wsgi_application()(next_app)
    if '--debug' in sys.argv:
        next_app = middleware.DebugMiddleware(next_app)
        LOG.debug("Routes: %s" % ['%s %s' % (r.method, r.rule) for r in
                                  app().routes])

    # Pick up IP/port from last param
    ip = '127.0.0.1'
    port = 8080
    if len(sys.argv) > 0:
        supplied = sys.argv[-1]
        if len([c for c in supplied if c in '%s:.' % string.digits]) == \
                len(supplied):
            if ':' in supplied:
                ip, port = supplied.split(':')
            else:
                ip = supplied
    server = 'wsgiref'
    if '--eventlet' in sys.argv:
        server = 'eventlet'
    run(app=next_app, host=ip, port=port, reloader=True, server=server)


#
# Main function
#
if __name__ == '__main__':
    main_func()
