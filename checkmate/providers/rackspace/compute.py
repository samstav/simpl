import logging
import os

from novaclient.exceptions import EndpointNotFound, AmbiguousEndpoints
from novaclient.v1_1 import client
import openstack.compute
from SpiffWorkflow.operators import Attrib
from SpiffWorkflow.specs import Celery, Transform

from checkmate.exceptions import CheckmateNoTokenError, CheckmateNoMapping
from checkmate.providers import ProviderBase, register_providers
from checkmate.utils import get_source_body
from checkmate.workflows import wait_for

LOG = logging.getLogger(__name__)


class RackspaceComputeProviderBase(ProviderBase):
    vendor = 'rackspace'

    """Generic functions for rackspace Compute providers"""
    def __init__(self, provider, key=None):
        ProviderBase.__init__(self, provider, key=key)
        self.prep_task = None

    def prep_environment(self, wfspec, deployment):

        def get_keys_code(my_task):
            keys = []
            for key, value in my_task.attributes['context'].get('keys',
                        {}).iteritems():
                if 'public_key_ssh' in value:
                    keys.append(value['public_key_ssh'])
                elif 'public_key' in value:
                    LOG.warning("Code still using public_key without _ssh")
            if keys:
                path = '/root/.ssh/authorized_keys'
                if not 'files' in my_task.attributes:
                    my_task.attributes['files'] = {}
                keys_string = '\n'.join(keys)
                if path in my_task.attributes['files']:
                    my_task.attributes['files'][path] += keys_string
                else:
                    my_task.attributes['files'][path] = keys_string

        self.prep_task = Transform(wfspec, "Get Keys to Inject",
                transforms=[get_source_body(get_keys_code)],
                description="Collect keys into correct files syntax")

        #TODO: remove direct-coding to config provider task names
        config_spec = wfspec.task_specs['Create Chef Environment']
        config_spec.connect(self.prep_task)
        return {'root': self.prep_task, 'final': self.prep_task}


class LegacyProvider(RackspaceComputeProviderBase):
    name = 'legacy'

    def generate_template(self, deployment, resource_type, service, name=None):
        template = RackspaceComputeProviderBase.generate_template(self,
                deployment, resource_type, service, name=name)

        image = self.get_deployment_setting(deployment, 'os',
                resource_type=resource_type, service=service)
        if isinstance(image, int):
            pass
        elif image == 'Ubuntu 11.10':
            image = 119
        else:
            raise CheckmateNoMapping("No image mapping for '%s' in '%s'" % (
                    image, self.name))

        flavor = self.get_deployment_setting(deployment, 'memory',
                resource_type=resource_type, service=service, default=1)
        if isinstance(flavor, int):
            pass
        elif flavor == '512 Mb':
            flavor = 2
        else:
            raise CheckmateNoMapping("No flavor mapping for '%s' in '%s'" % (
                    flavor, self.name))

        template['flavor'] = flavor
        template['image'] = image
        return template

    def add_resource_tasks(self, resource, key, wfspec, deployment, context,
            wait_on=None):
        """
        :param resource: the dict of the resource generated by
                generate_template earlier
        :returns: returns the root task in the chain of tasks
        TODO: use environment keys instead of private key
        """

        create_server_task = Celery(wfspec, 'Create Server:%s' % key,
                           'stockton.server.distribute_create',
                           call_args=[Attrib('context'),
                           resource.get('dns-name')],
                           image=resource.get('image', 119),
                           flavor=resource.get('flavor', 1),
                           files=Attrib('files'),
                           ip_address_type='public',
                           prefix=key,
                           defines=dict(resource=key,
                                        provider=self.key,
                                        task_tags=['create']),
                           properties={'estimated_duration': 20})

        build_wait_task = Celery(wfspec, 'Check that Server is Up:%s'
                % key, 'stockton.server.distribute_wait_on_build',
                call_args=[Attrib('context'), Attrib('id')],
                password=Attrib('password'),
                identity_file=Attrib('private_key_path'),
                prefix=key,
                properties={'estimated_duration': 150},
                defines=dict(resource=key,
                             provider=self.key,
                             task_tags=['final']))
        create_server_task.connect(build_wait_task)

        if wait_on is None:
            wait_on = []
        wait_on.append(self.prep_task)
        join = wait_for(wfspec, create_server_task, wait_on,
                name="Server Wait on:%s" % key,
                defines=dict(resource=key,
                             provider=self.key,
                             task_tags=['root']))

        return dict(root=join, final=build_wait_task,
                create=create_server_task)

    def get_catalog(self, context, type_filter=None):
        api = self._connect(context)

        results = {}
        if type_filter is None or type_filter == 'type':
            images = api.images.list()
            results['types'] = {
                    i.id: {
                        'name': i.name,
                        'os': i.name,
                        } for i in images if int(i.id) < 1000}
        if type_filter is None or type_filter == 'image':
            images = api.images.list()
            results['images'] = {
                    i.id: {
                        'name': i.name
                        } for i in images if int(i.id) > 1000}
        if type_filter is None or type_filter == 'size':
            flavors = api.flavors.list()
            results['sizes'] = {
                f.id: {
                    'name': f.name,
                    'ram': f.ram,
                    'disk': f.disk,
                    } for f in flavors}

        return results

    def _connect(self, context):
        """Use context info to connect to API and return api object"""
        if not context.auth_tok:
            raise CheckmateNoTokenError()
        api = openstack.compute.Compute()
        api.client.auth_token = context.auth_tok

        def find_url(catalog):
            for service in catalog:
                if service['name'] == 'cloudServers':
                    endpoints = service['endpoints']
                    for endpoint in endpoints:
                        return endpoint['publicURL']

        url = find_url(context.catalog)
        api.client.management_url = url
        return api


class NovaProvider(RackspaceComputeProviderBase):
    name = 'nova'

    def generate_template(self, deployment, resource_type, service, name=None):
        template = RackspaceComputeProviderBase.generate_template(self,
                deployment, resource_type, service, name=name)

        # Find and translate image
        image = self.get_deployment_setting(deployment, 'os',
                resource_type=resource_type, service=service)

        if image == 'Ubuntu 11.10':
            image = '3afe97b2-26dc-49c5-a2cc-a2fc8d80c001'
        else:
            raise CheckmateNoMapping("No image mapping for '%s' in '%s'" % (
                    image, self.name))

        # Find and translate flavor
        flavor = self.get_deployment_setting(deployment, 'memory',
                resource_type=resource_type, service=service, default=2)
        if isinstance(flavor, int):
            pass
        else:
            raise CheckmateNoMapping("No flavor mapping for '%s' in '%s'" % (
                    flavor, self.name))

        template['flavor'] = flavor
        template['image'] = image
        return template

    def add_resource_tasks(self, resource, key, wfspec, deployment,
            context, wait_on=None):
        """
        :param resource: the dict of the resource generated by
                generate_template earlier
        :returns: returns the root task in the chain of tasks
        TODO: use environment keys instead of private key
        """
        create_server_task = Celery(wfspec, 'Create Server:%s' % key,
                           'stockton.nova.distribute_create',
                           call_args=[Attrib('context'),
                           resource.get('dns-name')],
                           image=resource.get('image',
                                    '3afe97b2-26dc-49c5-a2cc-a2fc8d80c001'),
                           flavor=resource.get('flavor', "1"),
                           files=Attrib('files'),
                           defines={"Resource": key},
                           properties={'estimated_duration': 20})

        build_wait_task = Celery(wfspec, 'Check that Server is Up:%s'
                % key, 'stockton.nova.distribute_wait_on_build',
                call_args=[Attrib('context'), Attrib('id'), 'root'],
                password=Attrib('password'),
                identity_file=Attrib('public_key_path'),
                properties={'estimated_duration': 150})
        create_server_task.connect(build_wait_task)

        if wait_on is None:
            wait_on = []
        wait_on.append(self.prep_task)
        join = wait_for(wfspec, create_server_task, wait_on,
                name="Server Wait on:%s" % key)

        return {'root': join, 'final': build_wait_task}

    def get_catalog(self, context, type_filter=None):
        api = self._connect(context)

        results = {}
        if type_filter is None or type_filter == 'type':
            images = api.images.list()
            results['types'] = {
                    i.id: {
                        'name': i.name,
                        'os': i.name,
                        } for i in images}
        if type_filter is None or type_filter == 'image':
            images = api.images.list()
            results['images'] = {
                    i.id: {
                        'name': i.name
                        } for i in images if False}
        if type_filter is None or type_filter == 'size':
            flavors = api.flavors.list()
            results['sizes'] = {
                f.id: {
                    'name': f.name,
                    'ram': f.ram,
                    'disk': f.disk,
                    } for f in flavors}

        if type_filter is None or type_filter == 'regions':
            regions = {}
            for service in context.catalog:
                if service['name'] == 'cloudServersOpenStack':
                    endpoints = service['endpoints']
                    for endpoint in endpoints:
                        if 'region' in endpoint:
                            regions[endpoint['region']] = endpoint['publicURL']
            results['regions'] = regions

        return results

    def _connect(self, context):
        """Use context info to connect to API and return api object"""
        #TODO: Hard-coded to Rax auth for now
        #FIXME: handle region in context
        if not context.auth_tok:
            raise CheckmateNoTokenError()
        os.environ['NOVA_RAX_AUTH'] = "Yes Please!"
        api = client.Client(context.user, 'dummy', None,
                "https://identity.api.rackspacecloud.com/v2.0",
                region_name=None, service_type="compute",
                service_name='cloudServersOpenStack')
        api.client.auth_token = context.auth_tok

        def find_url(catalog):
            for service in catalog:
                if service['name'] == 'cloudServersOpenStack':
                    endpoints = service['endpoints']
                    for endpoint in endpoints:
                        return endpoint['publicURL']

        url = find_url(context.catalog)
        api.client.management_url = url

        return api


register_providers([NovaProvider, LegacyProvider])
